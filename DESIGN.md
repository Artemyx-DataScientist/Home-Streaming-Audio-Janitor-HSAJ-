# Home Streaming Audio Janitor (HSAJ) — Design Draft v0.1

## 0. Краткая идея

Система для домашнего стримминга, которая:

- следит за аудиотекой на сервере;
- получает сигналы от Roon (блоки, лайки, история прослушиваний — частично);
- автоматически:
  - выделяет Dolby Atmos в отдельное хранилище;
  - находит мусор и дубли;
  - готовит файлы к удалению по понятным правилам (с задержками и карантином).

Roon используется как **UI и плеер**, а не как центр истины.  
Истина — в файловой системе и в нашей собственной БД.

---

## 1. Цели и не-цели

### 1.1. Цели

- Автоматизировать уборку аудиотеки:
  - удалять то, что *точно* не нужно;
  - снижать количество ручного “разгребания”.
- Защитить ценные вещи:
  - Atmos-релизы;
  - явные избранные (favorites / whitelisted).
- Уважать решения пользователя:
  - использовать блок/ban в Roon как главный сигнал к выносу.
- Делать все действия **обратимыми**:
  - через карантин и задержки по времени.
- Подготовить фундамент для “домашнего стримминга”:
  - Roon + телефон + удалённый доступ;
  - заливка музыки “с улицы” в `/inbox` с автораскладкой.

### 1.2. Не-цели

- Не писать свой плеер.
- Не вмешиваться во внутреннюю БД Roon.
- Не парсить бэкап Roon напрямую (используем только Restore + API).
- Не строить рекомендаций / “умный Spotify”. Система — про санитарный контроль.

---

## 2. Архитектура компонентов (high-level)

### 2.1. Компоненты

1. **File Scanner**
   - Сканирует указанные директории аудиотеки.
   - Читает теги (artist, album, title, year, duration, etc.).
   - Через `ffprobe` определяет:
     - формат
     - битрейт
     - кол-во каналов
     - наличие Atmos (по профилю/тегам).
   - Записывает данные в локальную БД (SQLite).

2. **Roon Integration Layer**
   - Работает через Roon Extension (node-roon-api или http-api).
   - Получает:
     - состояние блоков / банов / hidden;
     - избранное / теги (по возможности);
     - события воспроизведения (now playing, started, ended, skipped).
   - Превращает это в понятные HTTP/WebSocket/JSON-события для ядра HSAJ.

3. **Core Service (HSAJ Core)**
   - Основная логика.
   - Хранит свою SQLite:
     - `files`
     - `tracks`
     - `play_history`
     - `roon_blocks`
     - `candidates`
   - Реализует политику:
     - наследование блоков artist → album → track;
     - задержку N дней с момента ПЕРВОГО обнаружения блока;
     - иммунитет Atmos;
     - карантин и финальное удаление.

4. **Action Executor**
   - Выполняет изменения в файловой системе:
     - перемещает Atmos в отдельный каталог;
     - перемещает кандидатов в карантин (`/_quarantine_delete/YYYY-MM-DD/...`);
     - при включённом “жёстком режиме” — удаляет файлы по истечении второго таймера.
   - Все действия логируются.

5. **UI/CLI**
   - CLI-команды:
     - `scan` — пересканировать аудиотеку;
     - `sync-roon` — синхронизировать блоки/состояния;
     - `plan` — показать план действий (кто под удаление/перенос);
     - `apply` — применить план;
   - В перспективе: веб-интерфейс (FastAPI + простой front).

---

## 3. Источники данных и “истина”

### 3.1. Файловая система

**Источник истины про физические файлы.**

- Путь
- Размер
- Формат (flac/mp3/mkv/…)
- Каналы
- Atmos-флаг
- Tag-и (artist / album / title / duration…)

### 3.2. Roon

**Источник истины про пользовательские решения и поведение.**

- Состояния:
  - blocked / banned / hidden
  - favorite (если нужно)
  - теги (опционально)
- События:
  - начало/конец воспроизведения трека
  - skip

Roon не используется как БД — только как “сенсор”.

### 3.3. Локальная БД HSAJ

**Единственная общая БД, на которой живёт логика:**

- `files` — физические файлы
- `library_items` — треки/альбомы/артисты как логические объекты
- `roon_blocks` — сырые блоки с Roon (artist/album/track)
- `block_candidates` — вычисленные кандидаты на вынос, с таймерами
- `play_history` — история воспроизведений (из событий Roon)
- `actions_log` — что было перемещено/удалено/отменено

---

## 4. Логика блоков и удаления

### 4.1. Наследование блоков

Roon может блокировать:

- артиста
- альбом
- трек

Правила наследования:

- заблокирован **артист** → все его альбомы и треки считаются кандидатами (`blocked_by_artist`);
- заблокирован **альбом** → все треки альбома — кандидаты (`blocked_by_album`);
- заблокирован **трек** → только он (`blocked_by_track`).

При конфликте:

- приоритет `track > album > artist`.

### 4.2. Момент старта таймера

**Таймер N дней стартует не с момента клика в Roon, а с момента, когда HSAJ впервые увидел блок.**

- `first_seen_at` — когда блок впервые обнаружен тулзой;
- `planned_action_at = first_seen_at + N дней`;
- на каждом новом `sync-roon`:
  - если объект всё ещё заблокирован → обновляем `last_seen_at`, но не двигаем `planned_action_at`;
  - если объект больше НЕ заблокирован → статус `restored`, планируемое действие отменяется.

### 4.3. Карантин и удаление

Политика действий над кандидатом:

1. Проверка перед действием:
   - всё ещё заблокирован?
   - не Atmos?
   - не в списке whitelist (ручное исключение)?

2. Если всё ок, и `planned_action_at <= now`:
   - переносим файл в `/Music/_quarantine_delete/YYYY-MM-DD/...`;
   - статус кандидата → `quarantined`;
   - опционально создаём второй таймер `delete_after = now + M дней`.

3. По истечении `delete_after`:
   - при включённом auto-delete → физическое удаление;
   - иначе — только отчёт, решение вручную.

Все действия логируются в `actions_log`.

---

## 5. Работа с Dolby Atmos

### 5.1. Обнаружение

Для каждого файла используется `ffprobe`, парсится JSON:

- `stream.profile` содержит `Atmos`  
  **или**
- в `stream.tags` / `format.tags` встречается `Dolby Atmos` / `atmos`.

Функция `is_dolby_atmos(path) -> bool`:

- если есть `Atmos` в профиле или тегах → `True`;
- иначе `False`.

### 5.2. Политика

- Atmos-файлы **никогда не удаляются автоматически**.
- Если Atmos-файл находится вне целевого каталога `/Music/_dolby_atmos/...`:
  - он переносится туда с сохранением подструктуры (Artist/Album).
- Atmos-файлы исключаются из:
  - списка кандидатов на удаление (по блокам);
  - списка кандидатов по “никогда не слушал”.

---

## 6. Поведенческий скоринг (вторая линия обороны)

Помимо блоков, вводится мягкий скоринг “ненужности”:

Примеры факторов:

- не слушался ни разу;
- в библиотеке больше X месяцев;
- нет ни одного лайка/тега;
- находится в “test/inbox” папке дольше Y дней;
- есть более качественный дубликат (FLAC vs MP3).

Такие треки:

- **никогда не удаляются автоматически**;
- попадают в отчёт как `soft_candidates`;
- могут быть отправлены в карантин по ручному подтверждению.

---

## 7. CLI / API

### 7.1. CLI (черновой список команд)

- `hsaj scan`  
  Сканирует файловую систему, обновляет `files` и Atmos-флаги.

- `hsaj sync-roon`  
  Синхронизирует блоки/состояния и записывает в `roon_blocks`, пересчитывает `block_candidates`.

- `hsaj plan`  
  Показывает:
  - кого планируется переместить/удалить;
  - причину (`blocked_by_artist`, `blocked_by_album`, `never_played`, `duplicate`, etc.);
  - даты `first_seen_at` и `planned_action_at`.

- `hsaj apply`  
  Выполняет план:
  - переносит Atmos;
  - перемещает кандидатов в карантин;
  - (опционально) удаляет старые из карантина.

- `hsaj history`  
  Отчёт по play_history (для отладки).

### 7.2. Web API (на будущее)

Простой HTTP/JSON поверх того же ядра:

- `GET /plan`
- `POST /apply`
- `GET /stats`
- `GET /candidates?status=...`

---

## 8. Технологический стек (предложение)

- Ядро:
  - Python 3.x
  - FastAPI (как API-слой + опциональный веб)
  - SQLite (через SQLAlchemy / raw SQL)
- Интеграция:
  - Roon extension на Node.js (node-roon-api / roon-extension-http-api)
  - Взаимодействие с ядром HSAJ по HTTP/WebSocket
- Утилиты:
  - `ffprobe` для анализа аудио
  - `mutagen` для тегов

---

## 9. Конфигурация

Файл `hsaj.toml` / `config.yaml` (пример):

- пути к медиатеке:
  - `library_paths = [...]`
- путь к Atmos-каталогу:
  - `atmos_root = "/Music/_dolby_atmos"`
- путь к карантину:
  - `quarantine_root = "/Music/_quarantine_delete"`
- задержки:
  - `block_grace_days = 30`
  - `quarantine_delete_days = 60`
- режимы:
  - `auto_delete = false`
  - `enable_behavior_scoring = true`

---
